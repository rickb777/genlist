// Generated by: setup
// TypeWriter: Option
// Directive: +test on Num1

package main

import "fmt"

//-------------------------------------------------------------------------------------------------
// Num1Collection is an interface for collections of type Num1, including sets, lists and options (where present).
type Num1Collection interface {
	// Size gets the size/length of the collection.
	Size() int

	// IsEmpty returns true if the collection is empty.
	IsEmpty() bool

	// NonEmpty returns true if the collection is non-empty.
	NonEmpty() bool

	// IsSequence returns true for lists, but false otherwise.
	IsSequence() bool

	// IsSet returns true for sets, but false otherwise.
	IsSet() bool

	// Head returns the first element of a list or an arbitrary element of a set or the contents of an option.
	// Panics if the collection is empty.
	Head() Num1

	//-------------------------------------------------------------------------
	// ToSlice returns a plain slice containing all the elements in the collection.
	// This is useful for bespoke iteration etc.
	// For sequences, the order is well defined.
	// For non-sequences (i.e. sets) the first time it is used, order of the elements is not well defined. But
	// the order is stable, which means it will give the same order each subsequent time it is used.
	ToSlice() []Num1

	// ToInts gets all the elements in a slice of the underlying type, []int.
	ToInts() []int

	// Send sends all elements along a channel of type Num1.
	// For sequences, the order is well defined.
	// For non-sequences (i.e. sets) the first time it is used, order of the elements is not well defined. But
	// the order is stable, which means it will give the same order each subsequent time it is used.
	Send() <-chan Num1

	//-------------------------------------------------------------------------
	// Exists returns true if there exists at least one element in the collection that matches
	// the predicate supplied.
	Exists(predicate func(Num1) bool) bool

	// Forall returns true if every element in the collection matches the predicate supplied.
	Forall(predicate func(Num1) bool) bool

	// Foreach iterates over every element, executing a supplied function against each.
	Foreach(fn func(Num1))

	//-------------------------------------------------------------------------
	// Filter returns a new Num1Collection whose elements return true for a predicate function.
	// The relative order of the elements in the result is the same as in the
	// original collection.
	Filter(predicate func(Num1) bool) (result Num1Collection)

	// Partition returns two new Num1Collections whose elements return true or false for the predicate, p.
	// The first consists of all elements that satisfy the predicate and the second consists of
	// all elements that don't. The relative order of the elements in the results is the same as in the
	// original collection.
	Partition(p func(Num1) bool) (matching Num1Collection, others Num1Collection)

	//-------------------------------------------------------------------------
	// Equals verifies that another Num1Collection has the same size and elements as this one. Also,
	// if the collection is a sequence, the order must be the same.
	// Omitted if Num1 is not comparable.
	Equals(other Num1Collection) bool

	// Contains tests whether a given value is present in the collection.
	// Omitted if Num1 is not comparable.
	Contains(value Num1) bool

	//-------------------------------------------------------------------------
	// Sum sums Num1 elements.
	// Omitted if Num1 is not numeric.
	Sum() Num1

	// Mean computes the arithmetic mean of all elements. Panics if the collection is empty.
	// Omitted if Num1 is not numeric.
	Mean() float64

	// Min returns the minimum value of Num1List. In the case of multiple items being equally minimal,
	// the first such element is returned. Panics if the collection is empty.
	Min() Num1

	// Max returns the maximum value of Num1List. In the case of multiple items being equally maximal,
	// the first such element is returned. Panics if the collection is empty.
	Max() Num1

	//-------------------------------------------------------------------------
	// String gets a string representation of the collection. "[" and "]" surround
	// a comma-separated list of the elements.
	String() string

	// MkString gets a string representation of the collection. "[" and "]" surround a list
	// of the elements joined by the separator you provide.
	MkString(sep string) string

	// MkString3 gets a string representation of the collection. 'pfx' and 'sfx' surround a list
	// of the elements joined by the 'mid' separator you provide.
	MkString3(pfx, mid, sfx string) string
}

//-------------------------------------------------------------------------------------------------

// OptionalNum1 is an optional of type Num1. Use it where you want to be explicit about
// the presence or absence of data.
//
// Optional values follow a similar pattern to Scala Options. In particular, an option is a collection
// with a maximum cardinality of one. As such, options can be converted to/from lists and sets.
// See e.g. http://www.scala-lang.org/api/2.11.7/index.html#scala.Option
type OptionalNum1 struct {
	x *Num1
}

// shared none value
var noneNum1 = OptionalNum1{nil}

func NoNum1() OptionalNum1 {
	return noneNum1
}

func SomeNum1(x Num1) OptionalNum1 {

	return OptionalNum1{&x}

}

//-------------------------------------------------------------------------------------------------

// panics if option is empty
func (o OptionalNum1) Head() Num1 {
	return o.Get()
}

func (o OptionalNum1) Get() Num1 {
	if o.IsEmpty() {
		panic("Attempt to access non-existent value")
	}
	return *o.x
}

func (o OptionalNum1) GetOrElse(d func() Num1) Num1 {
	if o.IsEmpty() {
		return d()
	}
	return *o.x
}

func (o OptionalNum1) OrElse(alternative func() OptionalNum1) OptionalNum1 {
	if o.IsEmpty() {
		return alternative()
	}
	return o
}

//-------------------------------------------------------------------------------------------------

func (o OptionalNum1) Size() int {
	if o.IsEmpty() {
		return 0
	}
	return 1
}

func (o OptionalNum1) Len() int {
	return o.Size()
}

func (o OptionalNum1) IsEmpty() bool {
	return o.x == nil
}

func (o OptionalNum1) NonEmpty() bool {
	return o.x != nil
}

// IsSequence returns false for options.
func (o OptionalNum1) IsSequence() bool {
	return false
}

// IsSet returns false for options.
func (o OptionalNum1) IsSet() bool {
	return false
}

// IsDefined returns true if the option is defined, i.e. non-empty. This is an alias for NonEmpty().
func (o OptionalNum1) IsDefined() bool {
	return o.NonEmpty()
}

//-------------------------------------------------------------------------------------------------

func (o OptionalNum1) Find(predicate func(Num1) bool) OptionalNum1 {
	if o.IsEmpty() {
		return o
	}
	if predicate(*o.x) {
		return o
	}
	return noneNum1
}

func (o OptionalNum1) Exists(predicate func(Num1) bool) bool {
	if o.IsEmpty() {
		return false
	}
	return predicate(*o.x)
}

func (o OptionalNum1) Forall(predicate func(Num1) bool) bool {
	if o.IsEmpty() {
		return true
	}
	return predicate(*o.x)
}

func (o OptionalNum1) Foreach(fn func(Num1)) {
	if o.NonEmpty() {
		fn(*o.x)
	}
}

// Send gets a channel that will send all the elements in order.
func (o OptionalNum1) Send() <-chan Num1 {
	ch := make(chan Num1)
	go func() {
		if o.NonEmpty() {
			ch <- *o.x
		}
		close(ch)
	}()
	return ch
}

func (o OptionalNum1) Filter(predicate func(Num1) bool) Num1Collection {
	return o.Find(predicate)
}

func (o OptionalNum1) Partition(predicate func(Num1) bool) (Num1Collection, Num1Collection) {
	if o.IsEmpty() {
		return o, o
	}
	if predicate(*o.x) {
		return o, noneNum1
	}
	return noneNum1, o
}

func (o OptionalNum1) ToSlice() []Num1 {
	slice := make([]Num1, o.Size())
	if o.NonEmpty() {
		slice[0] = *o.x
	}
	return slice
}

// ToInts gets all the elements in a []int.
func (o OptionalNum1) ToInts() []int {
	slice := make([]int, o.Size())
	if o.NonEmpty() {
		slice[0] = int(*o.x)
	}
	return slice
}

//-------------------------------------------------------------------------------------------------
// These methods require Num1 be comparable.

// Equals verifies that one or more elements of Num1List return true for the passed func.
func (o OptionalNum1) Equals(other Num1Collection) bool {
	if o.IsEmpty() {
		return other.IsEmpty()
	}
	if other.IsEmpty() || other.Size() > 1 {
		return false
	}
	a := o.x
	s := other.ToSlice()
	b := s[0]
	return *a == b
}

func (o OptionalNum1) Contains(value Num1) bool {
	if o.IsEmpty() {
		return false
	}
	return *(o.x) == value
}

func (o OptionalNum1) Count(value Num1) int {
	if o.Contains(value) {
		return 1
	}
	return 0
}

// Distinct returns a new Num1Collection whose elements are all unique. For options, this simply returns the
// receiver.
// Omitted if Num1 is not comparable.
func (o OptionalNum1) Distinct() Num1Collection {
	return o
}

// Min returns the minimum value of Num1List. In the case of multiple items being equally minimal,
// the first such element is returned. Panics if the collection is empty.
func (o OptionalNum1) Min() Num1 {
	return o.Get()
}

// Max returns the maximum value of Num1List. In the case of multiple items being equally maximal,
// the first such element is returned. Panics if the collection is empty.
func (o OptionalNum1) Max() Num1 {
	return o.Get()
}

//-------------------------------------------------------------------------------------------------

// Sum sums Num1 elements.
// Omitted if Num1 is not numeric.
func (o OptionalNum1) Sum() Num1 {

	if o.IsEmpty() {
		return 0
	}
	return *(o.x)

}

// Mean computes the arithmetic mean of all elements.
// Panics if the list is empty.
func (o OptionalNum1) Mean() float64 {
	if o.IsEmpty() {
		panic("Cannot compute the arithmetic mean of zero-length OptionalNum1")
	}
	return float64(*(o.x))
}

//-------------------------------------------------------------------------------------------------

// String implements the Stringer interface to render the option as an array of one element.
func (o OptionalNum1) String() string {
	return o.MkString3("[", ",", "]")
}

// MkString concatenates the values as a string.
func (o OptionalNum1) MkString(sep string) string {
	return o.MkString3("", sep, "")
}

// MkString3 concatenates the values as a string.
func (o OptionalNum1) MkString3(pfx, mid, sfx string) string {
	if o.IsEmpty() {
		return fmt.Sprintf("%s%s", pfx, sfx)
	}
	return fmt.Sprintf("%s%v%s", pfx, *(o.x), sfx)
}

// MapToFoo transforms OptionalNum1 to OptionalFoo.
func (o OptionalNum1) MapToFoo(fn func(Num1) Foo) FooCollection {
	if o.IsEmpty() {
		return NoFoo()
	}

	u := fn(*(o.x))

	return SomeFoo(u)
}

// FlatMapToFoo transforms OptionalNum1 to OptionalFoo, by
// calling the supplied function on the enclosed instance, if any, and returning an option.
// The result is only defined if *both* the receiver is defined and the function returns a non-empty sequence.
func (o OptionalNum1) FlatMapToFoo(fn func(Num1) FooCollection) (result FooCollection) {
	if o.IsEmpty() {
		return NoFoo()
	}
	return fn(*(o.x))
}

// Option flags: {Collection:false List:false Option:true Set:false Tag:map[MapTo:true]}
